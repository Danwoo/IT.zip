# 키워드 마스킹
l = '나는 감자를 좋아하는 편이다. 그러나 감자칩은 진짜 좋아한다.'

keywords = '감자'

sentence = ""
lists = l.split(keywords)
print(lists)

n = 0
for i in lists:
    sentence += i
    if lists[n] == lists[-1]:
        break
    sentence += f"({n+1})"
    n += 1

print(sentence)

# 키워드 마스킹 함수
def keyword_masking(text, keyword):
    sentence=""
    text_list = text.split(keyword)
    n = 0
    for i in text_list:
        sentence += i
        if text_list[n] == text_list[-1]:
            break
        sentence += f"({n+1})"
        n += 1
    return sentence

print(keyword_masking(l, keywords))


# 문단 구분하기
''' 
    문단 단위로 나눈다 
    -> 해석 단위를 결정, 최소 해석 단위 기준을 정한다. (예: 단어 200개 이상, 문장 10개 이상 ...)
    -> 입력
'''



text = '''"소프트웨어 개발자는 세상 모든 사람이 사용하는 제품을 실제로 작동시키는 혁신 엔진 역할을 한다. 개발자를 기업의 가장 귀중한 자원이라고 하는 것도 이 때문이다. 최근 전 세계적으로 소프트웨어 엔지니어 수요가 줄었다고 하지만 2020~2030년 기간으로 보면 22% 증가할 전망이다.\n \n\nⓒ Getty Image Bank\n\n그런데 이 소중한 자원이 여전히 극심하게 '낭비되고' 있다. 비효율적인 프로세스와 코드 재작업이 대표적이다. 이렇게 개발자의 시간과 노력이 낭비되는 것을 '개발자 노역(developer toil)'이라고 한다. 스트라이프(Stripe)에 따르면 개발자는 이 같은 노역에 근무 시간의 절반 이상을 쓰며, 최대 80%에 이르기도 한다. 이처럼 무의미한 개발자 노역에 낭비되는 비용은 연간 850억 달러에 달한다. \n \n기업은 자체 엔지니어 팀에서 이 문제를 해결하는 데 어려움을 겪고 있고 상당수가 아무런 조치도 취하지 않고 있다. 그러나 과도한 개발자 노역이 미치는 영향은 직원 근속률에서 명확히 드러난다. 노역은 개발자에게 극심한 좌절감을 준다. 조사에 따르면 개발자의 70% 이상은 계속되는 작업으로 인해 만족도가 떨어지고 결과적으로 이직을 한다. 2021년 미국 노동통계국 보고서에 따르면 개발자의 평균 이직률이 역대 최고치인 57.3%를 기록했다.\n\n그렇다면 이런 개발자 노역을 줄일 방법은 없을까? 개발자 경험(DX)과 소프트웨어 복잡성, 결함 수정과 관련된 개발자 노역을 줄이는 방안을 집중적으로 살펴보자. 실제로 방지할 수 있는 재작업이 개발자 업무 시간의 40%를 차지하고 개발자 노역의 대부분을 차지한다. 개발자는 성능 및 보안과 같이 우선순위가 높은 영역의 런타임 동작을 이해하고 코딩의 결함 수정을 구현하는 데 많은 시간을 쓴다. 기업과 개발자 모두 피하고 싶어하는, 사용자에 영향을 미치는 문제이기 때문이다. \n \n'개발자 노역'의 원인 \n개발자 노역의 주 원인은 갈수록 커지는 현대 소프트웨어 애플리케이션의 규모와 복잡성이다. 애플리케이션 크기는 지난 10년 동안 계속 커져서 현재 평균 라인 수가 30만에 이른다. 오늘날 소프트웨어 애플리케이션은 방대한 코드 기반과 수천 가지 연결된 서비스, 마이크로서비스 등으로 구성되므로 각 코드 변경에 따라 영향을 받을 수 있는 기능 표면적도 매우 넓다. 시스템이 너무 복잡해서 코드 변경이 시스템 동작에 미칠 영향을 직관적으로 예측하기가 어렵고, 최선을 다한 테스트에서도 치명적인 문제를 찾지 못하는 경우가 많다. 복잡성으로 인해 문제를 사전에 발견하기가 어렵고 이는 재작업으로 이어진다. \n\n기업은 소프트웨어 애플리케이션을 만드는 툴과 기술, 라이브러리, 코드를 그저 이해하는 데만 수십억 달러를 쓴다. 데브옵스와 IT 관행이 잘 정립된 기업은 프로덕션 소프트웨어 시스템의 관찰가능성과 애플리케이션 성능 모니터링 등을 갖추고 있지만, 프로덕션 시스템에서 성능 저하를 감지한다고 해도 이는 낮은 코드 품질을 나타내는 후행 지표일 뿐이다. 오늘날 프로덕션 성능 문제의 40~90%는 코드 수준에서 발생한다. 성능 문제가 포착되지 않고 프로덕션 시스템까지 넘어갈 경우 해결하는 데 며칠 또는 몇 주가 걸릴 수 있다. \n\n하지만 안타깝게도 코드를 작성하는 환경에서는 개발자가 애플리케이션의 코드 관련 성능 문제를 테스트할 수 있는 정보가 없다. 관찰가능성 툴은 “로드”에 의존하는 경우가 많은데, 분석을 수행하기 위해 이러한 툴을 테스트, 스테이징 환경에 적용하는 것도 쉽지 않다. 게다가 성능 문제를 유발하는 코드 패턴은 복잡한 경우가 많다. 코드베이스의 “어디를 봐야 하는지” 모른다면 추적 또는 디버깅 데이터가 있다 해도 문제를 찾기는 거의 불가능하다. \n \n런타임 보안 분석의 부재 \n코드에서 보안 결함을 찾는 것은 보안 스캔, 버그 바운티, 레드 팀, 침투 테스트를 비롯한 여러 기법을 동원한 지속적인 싸움이다. 사이버 보안 툴에 대한 막대한 투자에도 불구하고 코드 관련 보안 결함 문제는 여전히 존재하며 수정되는 속도도 느리다. MITRE의 일반적인 취약점 목록과 OWASP의 상위 10대 목록을 보면, 부실한 액세스 제어와 같은 복잡한 코드 설계 문제가 소프트웨어 취약점의 중요한 영역으로 부상하고 있음을 보여준다. 이런 문제는 정적 애플리케이션 보안 테스트 툴로는 풀 수 없다. 코드의 런타임 동작에 대한 시야가 없으면 애플리케이션 보안 테스트 공백이 발생하게 된다. \n\n프로세스의 초기에 보안 결함을 식별하고 수정할 기회를 놓치면 개발자 경험(DX)은 부정적인 영향을 받게 된다. 안전한 코드는 모든 개발자가 원하는 기본적인 요건이다. 그러나 복잡한 서비스 환경에서 견고한 코드 보안 태세를 유지하고 새로운 기능을 적시에 제공하는 부담이 온전히 개발에 몰리면 개발자는 작성하는 코드 한줄마다 막중한 부담을 갖게 된다.\n \n관찰가능성으로 공백 메우기 \n소프트웨어 개발자 관점에서 보면 소프트웨어 개발 프로세스는 시급히 개선돼야 한다. 개발자의 창의성을 끌어내고 코드 제공 시간을 앞당겨 비즈니스를 개선하기 위한 새로운 범주의 툴이 필요하다.\n\n그 중 하나가 바로 앱맵(AppMap)이다. 앱맵은 개발자가 코드를 작성하는 과정에서 소프트웨어가 어떻게 동작하는지 볼 수 있어야 한다는 단순한 전제를 기반으로 만들어졌다. 개발자가 더 나은 코딩 의사 결정을 내리려면 코딩 과정에서 소프트웨어에 대한 동적 런타임 정보를 확보할 수 있어야 한다. 코딩 과정 중에 런타임 데이터를 가지면 개발자 개개인은 물론 개발 팀에 많은 혜택을 제공한다. \n\n앱맵은 프로덕션에 배포된 최신 코드나 풀 요청의 코드, 또는 현재 작업 중인 커밋되지 않은 최신 변경 사항 등 환경과 코드의 버전에 관계없이 코드가 실행되는 시점에서 코드의 동작에 대한 정보를 수집한다. 앱맵은 개발자가 코드를 작성하는 과정에서 소프트웨어의 내부 동작을 기록하고 시각화해 개발자가 코드를 더 잘 이해할 수 있도록 한다. 앱맵 데이터에는 라이브러리, API, 웹 서비스, 데이터 연결, I/O, 보안 모듈, 타이밍 데이터 등이 포함된다. 이 정보를 통해 개발자는 코드 자체의 객관적인 데이터를 사용해 새로운 런타임 관점으로 소프트웨어를 이해할 수 있다.\n \n\nⓒ AppMap\n \n코드 편집기에 런타임 분석 구현 \n앱맵은 비주얼 스튜디오 코드나 젯브레인 IDE 같은 개발자의 코드 편집기에 연결돼 런타임을 최적화하는 권장 사항을 알려준다. 문제가 있는 부분은 편집기에서 강조 표시되고 개선할 수 있는 관련 코드를 살펴보도록 한다. 또한, 앱맵은 조치 가능한 예측적인 성능 및 보안 분석을 코드 편집기 내에서 직접 제공하므로 개발자는 코드를 쓰는 동시에 개선해 재작업을 피할 수 있다. 코드 편집기에서 코드 작업을 마치기 전에 느린 API 요청, 반복적인 SQL 쿼리 및 기타 일반적인 코드 관련 성능 문제를 검토할 수 있다. \n\n앱맵은 기존 DAST, IAST 툴보다 더 빠를 뿐만 아니라 코드 수정과 관련된 결과물의 신뢰성도 높다. 레거시 툴은 애플리케이션에서 공격 벡터를 찾을 수는 있지만 취약점이 존재하는 정확한 코드 라인은 알려주지 않는다. 반면 앱맵은 재현성 부담을 덜어 애플리케이션에서 수정해야 할 특정 부분을 코드 라인 수준까지 구체적으로 찾는 것은 물론 그 이유도 알려준다. 앱맵 오픈소스 커뮤니티에서 코드 편집기에서 런타임 소프트웨어를 분석하는 더 다양한 모범 사례를 확인할 수 있다.\n \n\nⓒ AppMap\n\n성능과 보안은 앱맵이 코딩 프로세스 중에 자동으로 찾는 런타임 소프트웨어 흐름 중 일부 사례일 뿐이다. 오늘날 상당수 애플리케이션이 API 우선 서비스로 만들어지고 있음을 고려하면 오픈API 문서 자동 생성(이전의 스웨거독(SwaggerDoc))도 중요한 기능이다. API 문서를 최신 상태로 유지하려면 개발자는 많은 시간을 들여야 한다. 또한 다른 많은 형태의 문서와 마찬가지로 API 문서 역시 코드가 발전함에 따라 금방 '지난 정보'가 되는데 이때 이 기능이 큰 도움이 된다.\n \n\nⓒ AppMap\n\n현재 앱맵은 자바, 자바스크립트, 파이썬, 루비를 포함해 인기 있는 프로그래밍 언어와 프레임워크 대부분을 지원하고 지원 대상도 계속 추가하고 있다. 코드 편집기와 개발 툴에 긴밀하게 통합되므로 개발자는 일상적으로 하는 작업을 자연스럽게 연장하는 방식으로 사용할 수 있다.\n \n\nⓒ AppMap\n \n소프트웨어 개발자의 창의력 \n개발자의 코딩에 대한 열정을 유지하는 핵심 요소는 사용자를 위한 새로운 제품을 만든다는 희열이다. 비즈니스의 성공을 개발자들에 의존하는 기업이라면 개발자 경험을 우선시하고 노역을 줄여야 하는 이유다. 따라서 개발팀을 책임지는 임원은 깃허브 코파일럿 같이 코딩 환경에서 작동하는 생성형 코딩 툴은 물론 자율 소프트웨어 개발과 같은 새로운 툴과 접근 방법의 폭발적인 성장에 주목해야 한다. \n\n그러나 이것만으로 충분하지 않다. 이제 개발자 경험은, 정적인 환경을 뛰어넘어 코딩 작업 중에 런타임 데이터와 새로운 통찰력까지 확장해 관리해야 한다. 이를 통해 개발, 설계 및 소프트웨어 품질을 개선할 수 있다. 이런 변화에서 앱맵은 큰 역할을 할 수 있다. 개발 경험에 새로운 데이터, 즉 동적 런타임 데이터를 추가해 코드의 효율성을 개선하고 품질을 높인다. 2023년은 개발자 경험의 해다. 개발자 노역을 최소화하고 성공적인 애플리케이션을 완성하기 위한 새로운 접근 방법과 기술로 소프트웨어 개발 팀의 모든 역량과 창의성을 끌어 내야 할 시점이다."}
소프트웨어 개발자는 세상 모든 사람이 사용하는 제품을 실제로 작동시키는 혁신 엔진 역할을 한다. 개발자를 기업의 가장 귀중한 자원이라고 하는 것도 이 때문이다. 최근 전 세계적으로 소프트웨어 엔지니어 수요가 줄었다고 하지만 2020~2030년 기간으로 보면 22% 증가할 전망이다.
'''

result = ""

texts = text.split(keywords)
print(texts)

n = 0
for i in texts:
    result += i
    if texts[n] == texts[-1]:
        break
    result += f"({n+1})"
    n += 1

print(result)

'''문단 구분 -> 공백 (',')지우기 -> 텍스트 길이 파악 -> 해석 단위 구분
    문단 구분 : 따옴표를 찾아서 문자로 바꾼다. 예: _ 
    위의 구분 기호 기준으로 공백 지우기
    전체 텍스트 길이 파악
    예 : 500자 당 한 문장 -> 1번 문단 텍스트 길이 200자, 2번 텍스트 길이 210자, 3번 텍스트 길이 150자, 4번 텍스트 길이 100자
    1. 각 문단 별 텍스트 길이 파악
    2. 순차적으로 1+2 = 410자 < 500자
    3. 1+2+3 = 560자 > 500자 통과
    4. 4 = 100자 
'''

# 해석 단위 구분 함수
def split_into_paragraphs(text, max_length=500):
    paragraphs = text.split("\n\n")  # 문단을 구분하는 기준에 따라 수정 가능합니다.
    result = []
    current_paragraph = ""

    for paragraph in paragraphs:
        if len(current_paragraph) <= max_length:
            current_paragraph += paragraph + "\n\n"
        else:
            if current_paragraph:
                result.append(current_paragraph.strip())
            current_paragraph = ""

    if current_paragraph:
        result.append(current_paragraph)
    print(result[0])
    print(type(result[0]))
    return result


# 문단 단위로 분할된 결과 출력
paragraphs = split_into_paragraphs(text)
# for i, paragraph in enumerate(paragraphs):
#     print(f"문단 {i+1}:")
#     print(paragraph)
#     print()

# # 입력된 텍스트
# text = """
# 이렇게 여러 문단으로 된 글을
# 최소 500자 이상의 덩어리로
# 묶어주는 파이썬 코드를 작성해보겠습니다.
#
# 파이썬은 강력한 프로그래밍 언어로,
# 다양한 텍스트 처리 작업을 수행할 수 있습니다.
# 이번에는 입력된 텍스트를 문단 단위로 분할하는
# 함수를 작성해보겠습니다.
#
# 함수의 기본값으로는 500자를 설정하였지만,
# 필요에 따라 다른 값으로 설정할 수도 있습니다.
# """



